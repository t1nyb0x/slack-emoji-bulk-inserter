# タスク: Slack絵文字一括登録

**入力**: `/specs/001-bulk-emoji-insert/` からの設計ドキュメント
**前提条件**: plan.md（必須）、spec.md（ユーザーストーリーに必須）、research.md、data-model.md、contracts/

**テスト**: 仕様でテストは要求されていないため、テストタスクは含まれていません。

**整理**: タスクはユーザーストーリーごとにグループ化されており、各ストーリーの独立した実装とテストを可能にしています。

## 形式: `[ID] [P?] [Story] 説明`

- **[P]**: 並列実行可能（異なるファイル、依存関係なし）
- **[Story]**: このタスクが属するユーザーストーリー（例: US1、US2）
- 説明に正確なファイルパスを含めること

## パス規約

- **単一プロジェクト**: リポジトリルートの `src/`
- ビルド出力: `dist/`
- 設定ファイル: リポジトリルート

---

## フェーズ1: セットアップ（共有インフラストラクチャ）

**目的**: プロジェクトの初期化とビルド環境の構築

- [ ] T001 npmプロジェクトを初期化し、package.jsonにtypescript・esbuild・@types/chromeを依存関係として追加
- [ ] T002 [P] tsconfig.jsonを作成し、strict mode・target ESNext・module ESNext・outDir dist/を設定
- [ ] T003 [P] esbuild.config.mjsを作成し、エントリポイントsrc/content.ts→dist/content.jsのバンドル設定を記述
- [ ] T004 [P] manifest.jsonを作成し、Manifest V3・content_scripts（matches: `https://*.slack.com/customize/emoji*`）・最小限のpermissionsのみ宣言（FR-008対応: 不要な情報収集を防止）

---

## フェーズ2: 基盤（ブロッキング前提条件）

**目的**: すべてのユーザーストーリーが依存する型定義とコアユーティリティの実装

**⚠️ 重要**: このフェーズが完了するまでユーザーストーリーの作業は開始不可

- [ ] T005 [P] src/types.tsに型定義を作成（EmojiRegistrationItem・EmojiStatus列挙型・SlackApiConfig。data-model.mdに基づく）
- [ ] T006 [P] src/utils/token.tsにAPIトークン抽出を実装（`<script>`タグのinnerTextから正規表現`/"?api_token"?\s*:\s*"([^"]+)"/`で`xoxs-`トークンを抽出。research.mdの決定事項2に基づく）
- [ ] T007 [P] src/utils/normalize.tsに絵文字名正規化を実装（5ステップ: 拡張子除去→小文字変換→空白・ドットを`_`置換→不正文字除去→空文字列チェック。data-model.mdのバリデーションルールに基づく）

**チェックポイント**: 基盤準備完了 - ユーザーストーリーの実装を開始可能

---

## フェーズ3: ユーザーストーリー1 - 絵文字の一括ドラッグ＆ドロップ登録（優先度: P1）🎯 MVP

**目標**: カスタマイズページのドロップゾーンに画像をドラッグ＆ドロップすると、各画像がSlack内部APIで順次絵文字として登録される

**独立テスト**: カスタマイズページでドロップゾーンに画像をドロップし、絵文字が実際にSlackに登録され、絵文字名がリスト上に表示されることを確認する

**対応要件**: FR-001, FR-002, FR-003, FR-004, FR-007, FR-009, FR-010, FR-012, FR-013

### ユーザーストーリー1の実装

- [ ] T008 [P] [US1] src/utils/emoji-api.tsにemoji.add API呼び出しを実装（fetch + FormData構築・token/name/mode/imageフィールド送信・レスポンスのokフィールド判定・エラーコード返却。contracts/emoji-add-api.mdに基づく）
- [ ] T009 [P] [US1] src/ui/drop-zone.tsにドロップゾーンUIを実装（ページ上部への固定パネル挿入・dragenter/dragover/dragleave/dropイベント処理・ドラッグ中のハイライト表示・MIMEタイプフィルタリングでimage/png・image/jpeg・image/gifのみ受付）
- [ ] T010 [P] [US1] src/ui/status-list.tsに絵文字リストUIを実装（絵文字名の一覧表示・リストへのアイテム追加・スクロール対応で100件以上表示可能）
- [ ] T011 [US1] src/content.tsにContent Scriptエントリポイントを実装（トークン抽出→ドロップゾーン生成→ファイルドロップ時に正規化・バリデーション・キュー追加→キューの順次処理（500ms〜1秒の固定ディレイ）→処理中の追加ドロップはキュー末尾に追加して継続）

**チェックポイント**: この時点で、画像をドロップすると絵文字がSlackに登録され、絵文字名がリストに表示される。ユーザーストーリー1は完全に機能し、独立してテスト可能であるべき

---

## フェーズ4: ユーザーストーリー2 - 登録状況のリアルタイム表示（優先度: P2）

**目標**: 各絵文字の登録状態（待機中・処理中・成功・失敗）がステータスアイコンでリアルタイムに更新され、登録の進捗を一目で把握できる

**独立テスト**: 複数の画像をドロップし、各絵文字の横にステータスアイコン（⏳→🔄→✅/❌）が表示され、登録の進行に伴いアイコンが変化することを目視確認する

**対応要件**: FR-005, FR-006, FR-011

### ユーザーストーリー2の実装

- [ ] T012 [US2] src/ui/status-list.tsにステータスアイコン描画を追加（EmojiStatusに対応するアイコン: pending=⏳・uploading=🔄・success=✅・failed=❌。各リストアイテムの先頭にアイコンを表示）
- [ ] T013 [US2] src/content.tsにリアルタイムステータス更新を追加（キュー処理の各段階でEmojiRegistrationItemのstatusを更新し、status-list.tsの描画更新関数を呼び出す。失敗時はerrorCodeも設定）
- [ ] T014 [US2] src/ui/status-list.tsに登録サマリー表示を追加（全アイテム処理完了後に成功件数・失敗件数を集計して表示。FR-011 Couldに対応）

**チェックポイント**: この時点で、ユーザーストーリー1と2の両方が独立して機能し、絵文字登録のステータスがリアルタイムに可視化されるべき

---

## フェーズ5: ポリッシュとクロスカッティング関心事

**目的**: ドキュメント整備と最終検証

- [ ] T015 [P] README.mdを更新（プロジェクト概要・セットアップ手順・ビルド方法・Chrome拡張機能のインストール手順・使い方を記述）
- [ ] T016 quickstart.mdの手順に従い、ビルド→Chrome読み込み→カスタマイズページでの動作を検証

---

## 依存関係と実行順序

### フェーズの依存関係

- **セットアップ（フェーズ1）**: 依存関係なし - すぐに開始可能
- **基盤（フェーズ2）**: セットアップの完了に依存 - すべてのユーザーストーリーをブロック
- **ユーザーストーリー1（フェーズ3）**: 基盤の完了に依存
- **ユーザーストーリー2（フェーズ4）**: ユーザーストーリー1の完了に依存（ステータス表示は登録処理が前提）
- **ポリッシュ（フェーズ5）**: すべてのユーザーストーリーの完了に依存

### ユーザーストーリーの依存関係

- **ユーザーストーリー1（P1）**: 基盤（フェーズ2）後に開始可能 - 他のストーリーへの依存なし
- **ユーザーストーリー2（P2）**: ユーザーストーリー1の完了に依存 - ステータス表示は登録処理が機能していることが前提

### 各ユーザーストーリー内

- モデル/型定義は基盤フェーズで完了済み
- ユーティリティ（API呼び出し、UI部品）は並列作成可能
- エントリポイント（content.ts）はすべてのモジュールに依存するため最後に実装
- 次の優先度に移る前にストーリーを完了

### 並列実行の機会

- T002/T003/T004: セットアップの設定ファイルは並列作成可能
- T005/T006/T007: 基盤の型定義・ユーティリティは並列作成可能
- T008/T009/T010: US1のAPI呼び出し・ドロップゾーン・リストUIは並列作成可能
- US1とUS2は依存関係があるため逐次実行が必要

---

## 並列実行例: ユーザーストーリー1

```bash
# US1のすべての独立モジュールを同時に開始:
タスク: "src/utils/emoji-api.tsにemoji.add API呼び出しを実装"
タスク: "src/ui/drop-zone.tsにドロップゾーンUIを実装"
タスク: "src/ui/status-list.tsに絵文字リストUIを実装"

# 上記3つの完了後にエントリポイントを実装:
タスク: "src/content.tsにContent Scriptエントリポイントを実装"
```

---

## 実装戦略

### MVPファースト（ユーザーストーリー1のみ）

1. フェーズ1完了: セットアップ（package.json、tsconfig.json、esbuild設定、manifest.json）
2. フェーズ2完了: 基盤（型定義、トークン抽出、絵文字名正規化）
3. フェーズ3完了: ユーザーストーリー1（API呼び出し、ドロップゾーン、リスト表示、エントリポイント）
4. **停止して検証**: 画像をドロップして絵文字が実際にSlackに登録されることを確認
5. 準備ができたらデプロイ/デモ

### インクリメンタルデリバリー

1. セットアップ + 基盤完了 → 基盤準備完了
2. ユーザーストーリー1追加 → ドロップ＆登録が動作 → デモ（MVP！）
3. ユーザーストーリー2追加 → ステータスアイコンでリアルタイムフィードバック → デモ
4. ポリッシュ → ドキュメント整備・最終検証

---

## メモ

- [P] タスク = 異なるファイル、依存関係なし
- [Story] ラベルはタスクを特定のユーザーストーリーにマッピングしてトレーサビリティを確保
- 各ユーザーストーリーは独立して完了・テスト可能であるべき
- 各タスクまたは論理的なグループの後にコミット
- 任意のチェックポイントで停止してストーリーを独立して検証可能
- テストは仕様で要求されていないため含まれていない
- 避けるべきこと: 曖昧なタスク、同一ファイルの競合、独立性を損なうクロスストーリー依存関係
