```chatagent
---
description: 現在のフィーチャーに対して、ユーザー要件に基づくカスタムチェックリストを生成します。
---

## チェックリストの目的：「要件記述のユニットテスト」

**重要な概念**: チェックリストは**要件記述のユニットテスト**です。特定ドメインにおける要件の品質、明確さ、完全性を検証します。

**検証/テスト用ではありません**：

- ❌ 「ボタンが正しくクリックできることを確認」ではない
- ❌ 「エラーハンドリングが機能することをテスト」ではない
- ❌ 「APIが200を返すことを確認」ではない
- ❌ コード/実装がspecに一致するかのチェックではない

**要件の品質検証用です**：

- ✅ 「すべてのカード種類に対してビジュアル階層の要件が定義されているか？」（完全性）
- ✅ 「『目立つ表示』は具体的なサイズ/配置で数値化されているか？」（明確性）
- ✅ 「すべてのインタラクティブ要素でホバー状態の要件が一貫しているか？」（一貫性）
- ✅ 「キーボードナビゲーションのアクセシビリティ要件が定義されているか？」（カバレッジ）
- ✅ 「ロゴ画像の読み込み失敗時の動作がspecに定義されているか？」（エッジケース）

**メタファー**: specが英語で書かれたコードだとしたら、チェックリストはそのユニットテストスイートです。要件が適切に書かれ、完全で、曖昧さがなく、実装準備ができているかをテストするものであり、実装が動作するかどうかのテストではありません。

## ユーザー入力

```text
$ARGUMENTS
```

以下に進む前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 実行ステップ

1. **セットアップ**: リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json` を実行し、JSONからFEATURE_DIRとAVAILABLE_DOCSリストを解析します。
   - すべてのファイルパスは絶対パスでなければなりません。
   - 引数にシングルクォートが含まれる場合（例: "I'm Groot"）は、エスケープ構文を使用してください: 例 'I'\''m Groot'（または可能であればダブルクォート: "I'm Groot"）。

2. **意図の明確化（動的）**: ユーザーのフレーズ + spec/plan/tasksから抽出したシグナルに基づいて、最大3つの初期コンテキスト明確化質問を導出します。以下の条件を満たす必要があります：
   - ユーザーの表現 + 抽出されたシグナルから生成される
   - チェックリストの内容に実質的な変更をもたらす情報のみを質問
   - `$ARGUMENTS` で既に明確な場合は個別にスキップ
   - 広さより精度を優先

   生成アルゴリズム：
   1. シグナルの抽出: フィーチャードメインキーワード（例: auth、latency、UX、API）、リスク指標（「critical」「must」「compliance」）、ステークホルダーヒント（「QA」「review」「security team」）、明示的な成果物（「a11y」「rollback」「contracts」）。
   2. シグナルを候補フォーカスエリアにクラスタリング（最大4つ）し、関連性でランク付け。
   3. 推定される対象者とタイミング（作成者、レビューアー、QA、リリース）を特定。
   4. 不足している次元を検出: スコープの広さ、深さ/厳密さ、リスク重視、除外境界、測定可能な受け入れ基準。
   5. 以下のアーキタイプから質問を策定:
      - スコープの改善
      - リスクの優先順位付け
      - 深さの調整
      - 対象者のフレーミング
      - 境界の除外
      - シナリオクラスのギャップ

   質問のフォーマットルール：
   - 選択肢を提示する場合、列：Option | 候補 | 重要な理由 を含むコンパクトなテーブルを生成
   - 最大A〜Eの選択肢に制限
   - ユーザーが既に述べたことの繰り返しを求めない
   - 推測的なカテゴリを避ける（ハルシネーションなし）

   対話が不可能な場合のデフォルト:
   - 深さ: 標準
   - 対象者: コード関連ならレビューアー（PR）、それ以外は作成者
   - フォーカス: 上位2つの関連性クラスタ

   質問を出力します（Q1/Q2/Q3とラベル付け）。回答後: 合計5つの質問を超えないでください。

3. **ユーザーリクエストの理解**: `$ARGUMENTS` + 明確化の回答を統合:
   - チェックリストテーマの導出（例: security、review、deploy、ux）
   - ユーザーが言及した明示的な必須項目の統合
   - フォーカス選択をカテゴリスキャフォールディングにマッピング
   - spec/plan/tasksから不足コンテキストを推論（ハルシネーション**しないでください**）

4. **フィーチャーコンテキストの読み込み**: FEATURE_DIRから読み込み:
   - spec.md: フィーチャー要件とスコープ
   - plan.md（存在する場合）: 技術的詳細、依存関係
   - tasks.md（存在する場合）: 実装タスク

   **コンテキスト読み込み戦略**:
   - アクティブなフォーカスエリアに関連する必要な部分のみを読み込み
   - 長いセクションは簡潔なシナリオ/要件箇条書きに要約
   - 段階的開示を使用
   - ソースドキュメントが大きい場合、中間サマリー項目を生成

5. **チェックリストの生成** - 「要件のユニットテスト」を作成:
   - `FEATURE_DIR/checklists/` ディレクトリが存在しない場合は作成
   - 一意のチェックリストファイル名を生成:
     - ドメインに基づく短い説明的な名前を使用（例: `ux.md`、`api.md`、`security.md`）
     - 形式: `[domain].md`
     - ファイルが存在する場合は既存ファイルに追記
   - 項目にCHK001から順番に番号を付与
   - 各 `/speckit.checklist` 実行で新しいファイルを作成（既存チェックリストを上書きしない）

   **コア原則 - 実装ではなく要件をテストする**:
   すべてのチェックリスト項目は、以下の観点で要件自体を評価する必要があります：
   - **完全性**: 必要なすべての要件が存在するか？
   - **明確性**: 要件は曖昧さがなく具体的か？
   - **一貫性**: 要件は相互に整合しているか？
   - **測定可能性**: 要件は客観的に検証可能か？
   - **カバレッジ**: すべてのシナリオ/エッジケースが対処されているか？

   **カテゴリ構造** - 要件品質の次元でグループ化:
   - **要件の完全性**
   - **要件の明確性**
   - **要件の一貫性**
   - **受け入れ基準の品質**
   - **シナリオカバレッジ**
   - **エッジケースカバレッジ**
   - **非機能要件**
   - **依存関係と前提条件**
   - **曖昧さと矛盾**

   **チェックリスト項目の書き方**:

   ❌ **間違い**（実装をテストしている）:
   - 「ランディングページに3つのエピソードカードが表示されることを確認」
   - 「デスクトップでホバー状態が機能することをテスト」

   ✅ **正解**（要件の品質をテストしている）:
   - 「注目エピソードの正確な数とレイアウトが指定されているか？」[完全性]
   - 「『目立つ表示』は具体的なサイズ/配置で数値化されているか？」[明確性]
   - 「すべてのインタラクティブ要素でホバー状態の要件が一貫しているか？」[一貫性]

   **項目の構造**:
   - 要件の品質について質問する形式
   - spec/planに書かれていること（または書かれていないこと）に焦点
   - 品質次元を括弧内に含む [完全性/明確性/一貫性/等]
   - 既存要件をチェックする場合はspecセクション `[Spec §X.Y]` を参照
   - 欠落要件をチェックする場合は `[Gap]` マーカーを使用

   **トレーサビリティ要件**:
   - 最低基準: 項目の≥80%が少なくとも1つのトレーサビリティ参照を含む必要あり
   - 各項目はspecセクション `[Spec §X.Y]` を参照するか、マーカー: `[Gap]`、`[曖昧性]`、`[矛盾]`、`[前提]` を使用

   **コンテンツの統合**:
   - ソフトキャップ: 生の候補項目が40を超える場合、リスク/影響度で優先順位付け
   - 同じ要件側面をチェックする類似重複をマージ

   **🚫 絶対に禁止**:
   - ❌ 「確認」「テスト」「検証」「チェック」+ 実装動作で始まる項目
   - ❌ コード実行、ユーザーアクション、システム動作への参照
   - ❌ テストケース、テスト計画、QA手順
   - ❌ 実装詳細（フレームワーク、API、アルゴリズム）

   **✅ 必須パターン**:
   - ✅ 「[シナリオ]に対する[要件タイプ]が定義/指定/ドキュメント化されているか？」
   - ✅ 「[曖昧な用語]は具体的な基準で数値化/明確化されているか？」
   - ✅ 「[セクションA]と[セクションB]の間で要件は一貫しているか？」
   - ✅ 「[要件]は客観的に測定/検証可能か？」
   - ✅ 「specに[欠落している側面]が定義されているか？」

6. **構造の参照**: `.specify/templates/checklist-template.md` の正規テンプレートに従ってチェックリストを生成します。テンプレートが利用できない場合は以下を使用: H1タイトル、目的/作成日メタ行、CHK001から始まるグローバルインクリメントIDを持つ `- [ ] CHK### <要件項目>` 行を含む `##` カテゴリセクション。

7. **レポート**: 作成されたチェックリストのフルパス、項目数を出力し、各実行で新しいファイルが作成されることをユーザーに通知します。

**重要**: 各 `/speckit.checklist` コマンド呼び出しでは、ファイルが既に存在しない限り、短く説明的な名前を使用してチェックリストファイルを作成します。

## チェックリストタイプと項目の例

**UX要件品質:** `ux.md`
- 「ビジュアル階層の要件が測定可能な基準で定義されているか？ [明確性, Spec §FR-1]」
- 「UI要素の数と配置が明示的に指定されているか？ [完全性, Spec §FR-1]」
- 「すべてのインタラクティブ要素にアクセシビリティ要件が指定されているか？ [カバレッジ, Gap]」

**API要件品質:** `api.md`
- 「すべての障害シナリオに対するエラーレスポンス形式が指定されているか？ [完全性]」
- 「レート制限の要件が具体的な閾値で数値化されているか？ [明確性]」

**セキュリティ要件品質:** `security.md`
- 「すべての保護リソースに認証要件が指定されているか？ [カバレッジ]」
- 「脅威モデルがドキュメント化され、要件がそれに整合しているか？ [トレーサビリティ]」

## アンチパターン

**❌ 間違い - 実装をテストしている:**
```markdown
- [ ] CHK001 - ランディングページに3つのエピソードカードが表示されることを確認 [Spec §FR-001]
```

**✅ 正解 - 要件の品質をテストしている:**
```markdown
- [ ] CHK001 - 注目エピソードの数とレイアウトが明示的に指定されているか？ [完全性, Spec §FR-001]
```

**主な違い:**
- 間違い: システムが正しく動作するかをテスト
- 正解: 要件が正しく書かれているかをテスト

```
