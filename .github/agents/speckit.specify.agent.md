```chatagent
---
description: 自然言語のフィーチャー説明からフィーチャー仕様を作成または更新します。
handoffs: 
  - label: 技術計画の作成
    agent: speckit.plan
    prompt: 仕様の計画を作成してください。使用する技術は...
  - label: 仕様要件の明確化
    agent: speckit.clarify
    prompt: 仕様の要件を明確化してください
    send: true
---

## ユーザー入力

```text
$ARGUMENTS
```

以下に進む前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 概要

ユーザーが `/speckit.specify` の後に入力したテキストがフィーチャー説明**です**。`$ARGUMENTS` が文字通り表示されていても、この会話で常に利用可能であると仮定してください。空のコマンドが入力された場合を除き、ユーザーに繰り返しを求めないでください。

そのフィーチャー説明に基づいて、以下を実行してください:

1. **簡潔な短縮名を生成**（2〜4語）、ブランチ用:
   - フィーチャー説明を分析し、最も意味のあるキーワードを抽出
   - フィーチャーの本質を捉えた2〜4語の短縮名を作成
   - 可能であればアクション-名詞の形式を使用（例: "add-user-auth"、"fix-payment-bug"）
   - 技術用語や略語を保持（OAuth2、API、JWT等）
   - 一目でフィーチャーを理解できる程度に簡潔かつ説明的に
   - 例:
     - "ユーザー認証を追加したい" → "user-auth"
     - "APIにOAuth2統合を実装" → "oauth2-api-integration"
     - "分析用ダッシュボードを作成" → "analytics-dashboard"
     - "決済処理タイムアウトバグを修正" → "fix-payment-timeout"

2. **新規ブランチ作成前に既存ブランチを確認**:

   a. まず、最新情報を取得するためにすべてのリモートブランチをフェッチ:

      ```bash
      git fetch --all --prune
      ```

   b. その短縮名に対する最大のフィーチャー番号をすべてのソースから検索:
      - リモートブランチ: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - ローカルブランチ: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - specsディレクトリ: `specs/[0-9]+-<short-name>` に一致するディレクトリを確認

   c. 次に利用可能な番号を決定:
      - 3つすべてのソースからすべての番号を抽出
      - 最大番号Nを見つける
      - 新しいブランチ番号としてN+1を使用

   d. 計算された番号と短縮名でスクリプト `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` を実行:
      - `--number N+1` と `--short-name "your-short-name"` をフィーチャー説明と共に渡す
      - Bashの例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShellの例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**:
   - 最大番号を見つけるために3つのソース（リモートブランチ、ローカルブランチ、specsディレクトリ）すべてを確認
   - 完全一致の短縮名パターンのブランチ/ディレクトリのみをマッチ
   - この短縮名で既存のブランチ/ディレクトリが見つからない場合、番号1から開始
   - このスクリプトは1つのフィーチャーにつき1回のみ実行すること
   - JSONはターミナル出力として提供されます - 探しているコンテンツを取得するために常にそれを参照してください
   - JSON出力にはBRANCH_NAMEとSPEC_FILEのパスが含まれます
   - 引数にシングルクォートが含まれる場合（例: "I'm Groot"）は、エスケープ構文を使用: 例 'I'\''m Groot'（または可能であればダブルクォート: "I'm Groot"）

3. `.specify/templates/spec-template.md` を読み込んで必要なセクションを理解します。

4. 以下の実行フローに従います:

    1. 入力からユーザー説明を解析
       空の場合: ERROR "フィーチャー説明が提供されていません"
    2. 説明からキーコンセプトを抽出
       識別対象: アクター、アクション、データ、制約
    3. 不明確な側面について:
       - コンテキストと業界標準に基づいて合理的な推測を行う
       - 以下の場合にのみ [NEEDS CLARIFICATION: 具体的な質問] でマーク:
         - その選択がフィーチャーのスコープやユーザー体験に大きく影響する
         - 異なる影響を持つ複数の合理的な解釈が存在する
         - 合理的なデフォルトが存在しない
       - **制限: [NEEDS CLARIFICATION] マーカーは合計3つまで**
       - 明確化の優先順位: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術的詳細
    4. ユーザーシナリオとテストセクションを記入
       明確なユーザーフローがない場合: ERROR "ユーザーシナリオを特定できません"
    5. 機能要件を生成
       各要件はテスト可能でなければならない
       未指定の詳細にはデフォルトを使用（仮定セクションに文書化）
    6. 成功基準を定義
       測定可能で技術に依存しない成果を作成
       定量的指標（時間、パフォーマンス、ボリューム）と定性的指標（ユーザー満足度、タスク完了）の両方を含む
       各基準は実装詳細なしで検証可能でなければならない
    7. キーエンティティの識別（データが関与する場合）
    8. 戻り: SUCCESS（仕様が計画の準備完了）

5. テンプレートの構造を使用してSPEC_FILEに仕様を書き込み、セクションの順序と見出しを保持しながら、プレースホルダーをフィーチャー説明（引数）から導出した具体的な詳細に置き換えます。

6. **仕様品質の検証**: 初期仕様を書いた後、品質基準に対して検証します:

   a. **仕様品質チェックリストの作成**: `FEATURE_DIR/checklists/requirements.md` にチェックリストテンプレートの構造で以下の検証項目を含むチェックリストファイルを生成:

      ```markdown
      # 仕様品質チェックリスト: [フィーチャー名]
      
      **目的**: 計画に進む前に仕様の完全性と品質を検証する
      **作成日**: [日付]
      **フィーチャー**: [spec.mdへのリンク]
      
      ## コンテンツ品質
      
      - [ ] 実装詳細なし（言語、フレームワーク、API）
      - [ ] ユーザー価値とビジネスニーズに焦点
      - [ ] 非技術的なステークホルダー向けに記述
      - [ ] すべての必須セクションが完了
      
      ## 要件の完全性
      
      - [ ] [NEEDS CLARIFICATION] マーカーが残っていない
      - [ ] 要件がテスト可能で曖昧さがない
      - [ ] 成功基準が測定可能
      - [ ] 成功基準が技術に依存しない（実装詳細なし）
      - [ ] すべての受け入れシナリオが定義されている
      - [ ] エッジケースが特定されている
      - [ ] スコープが明確に境界付けられている
      - [ ] 依存関係と仮定が特定されている
      
      ## フィーチャーの準備状態
      
      - [ ] すべての機能要件に明確な受け入れ基準がある
      - [ ] ユーザーシナリオが主要フローをカバー
      - [ ] 成功基準で定義された測定可能な成果をフィーチャーが達成
      - [ ] 仕様に実装詳細が混入していない
      
      ## メモ
      
      - 未完了としてマークされた項目は、`/speckit.clarify` または `/speckit.plan` の前に仕様の更新が必要
      ```

   b. **検証チェックの実行**: 各チェックリスト項目に対して仕様を検証:
      - 各項目のパス/フェイルを判定
      - 発見された具体的な問題を文書化（関連する仕様セクションを引用）

   c. **検証結果の処理**:

      - **すべての項目がパスした場合**: チェックリストを完了としてマークし、ステップ6に進む

      - **項目が失敗した場合（[NEEDS CLARIFICATION]を除く）**:
        1. 失敗した項目と具体的な問題をリスト
        2. 各問題に対処するために仕様を更新
        3. すべての項目がパスするまで検証を再実行（最大3回の反復）
        4. 3回の反復後もまだ失敗している場合、残りの問題をチェックリストのメモに文書化しユーザーに警告

      - **[NEEDS CLARIFICATION] マーカーが残っている場合**:
        1. 仕様からすべての [NEEDS CLARIFICATION: ...] マーカーを抽出
        2. **制限チェック**: 3つを超えるマーカーが存在する場合、最も重要な3つ（スコープ/セキュリティ/UXへの影響度順）のみを残し、残りは合理的な推測を行う
        3. 各明確化が必要な項目（最大3つ）について、以下の形式でユーザーに選択肢を提示:

           ```markdown
           ## 質問 [N]: [トピック]
           
           **コンテキスト**: [関連する仕様セクションを引用]
           
           **確認が必要な内容**: [NEEDS CLARIFICATIONマーカーからの具体的な質問]
           
           **提案する回答**:
           
           | 選択肢 | 回答 | 影響 |
           |--------|------|------|
           | A      | [最初の提案] | [フィーチャーへの影響] |
           | B      | [2番目の提案] | [フィーチャーへの影響] |
           | C      | [3番目の提案] | [フィーチャーへの影響] |
           | カスタム | 独自の回答を入力 | [カスタム入力の方法を説明] |
           
           **選択**: _[ユーザーの応答を待つ]_
           ```

        4. **重要 - テーブルのフォーマット**: マークダウンテーブルが正しくフォーマットされていることを確認:
           - パイプを揃えて一貫したスペース
           - 各セルの内容の周囲にスペース: `| コンテンツ |`（`|コンテンツ|` ではなく）
           - ヘッダーセパレーターには最低3つのダッシュ: `|--------|`
           - マークダウンプレビューでテーブルが正しくレンダリングされることをテスト
        5. 質問は連番（Q1、Q2、Q3 - 最大3つ）
        6. 応答を待つ前にすべての質問をまとめて提示
        7. ユーザーのすべての質問に対する回答を待つ（例: "Q1: A、Q2: カスタム - [詳細]、Q3: B"）
        8. 各 [NEEDS CLARIFICATION] マーカーをユーザーが選択または提供した回答で置き換えて仕様を更新
        9. すべての明確化が解決された後に検証を再実行

   d. **チェックリストの更新**: 各検証反復後に、現在のパス/フェイルステータスでチェックリストファイルを更新

7. 完了をブランチ名、仕様ファイルパス、チェックリスト結果、および次のフェーズ（`/speckit.clarify` または `/speckit.plan`）への準備状況と共に報告します。

**注意:** スクリプトは書き込み前に新しいブランチを作成・チェックアウトし、仕様ファイルを初期化します。

## 一般ガイドライン

## クイックガイドライン

- ユーザーが**何を**必要とし、**なぜ**必要かに焦点を当てる。
- 実装方法（技術スタック、API、コード構造）は避ける。
- 開発者ではなく、ビジネスステークホルダー向けに記述する。
- 仕様に埋め込まれたチェックリストは作成しないこと。それは別のコマンドで行います。

### セクション要件

- **必須セクション**: すべてのフィーチャーで記入が必要
- **オプションセクション**: フィーチャーに関連する場合のみ含める
- セクションが該当しない場合、「N/A」のまま残さず完全に削除

### AI生成向け

ユーザープロンプトからこの仕様を作成する際:

1. **合理的な推測を行う**: コンテキスト、業界標準、一般的なパターンを使用してギャップを埋める
2. **仮定を文書化**: 合理的なデフォルトを仮定セクションに記録
3. **明確化を制限**: [NEEDS CLARIFICATION] マーカーは最大3つ - 以下の重要な決定にのみ使用:
   - フィーチャーのスコープやユーザー体験に大きく影響する
   - 異なる影響を持つ複数の合理的な解釈が存在する
   - 合理的なデフォルトが存在しない
4. **明確化の優先順位**: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術的詳細
5. **テスターのように考える**: すべての曖昧な要件は「テスト可能で曖昧さがない」チェックリスト項目で不合格になるべき
6. **明確化が一般的に必要な領域**（合理的なデフォルトが存在しない場合のみ）:
   - フィーチャーのスコープと境界（特定のユースケースの包含/除外）
   - ユーザータイプと権限（複数の矛盾する解釈が可能な場合）
   - セキュリティ/コンプライアンス要件（法的/財務的に重要な場合）

**合理的なデフォルトの例**（これらについては質問しない）:

- データ保持: そのドメインの業界標準プラクティス
- パフォーマンス目標: 特に指定がない限り標準的なWeb/モバイルアプリの期待値
- エラーハンドリング: 適切なフォールバック付きのユーザーフレンドリーなメッセージ
- 認証方式: Webアプリの場合、標準的なセッションベースまたはOAuth2
- 統合パターン: 特に指定がない限りRESTful API

### 成功基準のガイドライン

成功基準は以下を満たす必要があります:

1. **測定可能**: 具体的な指標を含む（時間、パーセンテージ、数量、率）
2. **技術に依存しない**: フレームワーク、言語、データベース、ツールに言及しない
3. **ユーザー中心**: システム内部ではなく、ユーザー/ビジネスの観点から成果を記述
4. **検証可能**: 実装詳細を知らなくてもテスト/検証可能

**良い例**:

- 「ユーザーは3分以内にチェックアウトを完了できる」
- 「システムは10,000の同時ユーザーをサポートする」
- 「検索の95%が1秒以内に結果を返す」
- 「タスク完了率が40%向上する」

**悪い例**（実装に焦点を当てている）:

- 「APIレスポンスタイムが200ms未満」（技術的すぎる、「ユーザーが即座に結果を確認できる」を使用）
- 「データベースが1000 TPSを処理できる」（実装詳細、ユーザー向けの指標を使用）
- 「Reactコンポーネントが効率的にレンダリングされる」（フレームワーク固有）
- 「Redisキャッシュヒット率が80%以上」（技術固有）

```
