```chatagent
---
description: 現在のフィーチャー仕様の未定義領域を特定し、最大5つの高精度な明確化質問を行い、回答をspecに反映します。
handoffs: 
  - label: 技術計画の作成
    agent: speckit.plan
    prompt: specに基づいて計画を作成してください。使用技術は...
---

## ユーザー入力

```text
$ARGUMENTS
```

以下に進む前に、ユーザー入力を**必ず**考慮してください（空でない場合）。

## 概要

目標: アクティブなフィーチャー仕様の曖昧さや不足している決定ポイントを検出・削減し、明確化した内容をspecファイルに直接記録します。

注意: この明確化ワークフローは `/speckit.plan` を実行する**前に**実行（および完了）されることを想定しています。ユーザーが明示的に明確化をスキップすると述べた場合（例: 探索的スパイク）、続行できますが、下流での手戻りリスクが増加することを警告する必要があります。

実行ステップ:

1. リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --paths-only` を**一度**実行します（`--json --paths-only` の統合モード）。最小限のJSONペイロードフィールドを解析します：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （オプションで将来のチェーンフロー用に `IMPL_PLAN`、`TASKS` を取得可能。）
   - JSON解析に失敗した場合、中断して `/speckit.specify` の再実行またはフィーチャーブランチ環境の確認を指示します。
   - 引数にシングルクォートが含まれる場合（例: "I'm Groot"）は、エスケープ構文を使用してください: 例 'I'\''m Groot'（または可能であればダブルクォート: "I'm Groot"）。

2. 現在のspecファイルを読み込みます。以下の分類法を使用して構造化された曖昧性・カバレッジスキャンを実行します。各カテゴリについてステータスを記録: Clear / Partial / Missing。優先順位付けに使用する内部カバレッジマップを作成します（質問がない場合を除き、生のマップは出力しないでください）。

   機能スコープと動作:
   - コアユーザー目標と成功基準
   - 明示的なスコープ外宣言
   - ユーザーロール/ペルソナの区別

   ドメインとデータモデル:
   - エンティティ、属性、関係
   - 同一性と一意性のルール
   - ライフサイクル/状態遷移
   - データ量/スケールの前提

   インタラクションとUXフロー:
   - クリティカルなユーザージャーニー/シーケンス
   - エラー/空/読み込み状態
   - アクセシビリティまたはローカライゼーションの注記

   非機能品質属性:
   - パフォーマンス（レイテンシ、スループット目標）
   - スケーラビリティ（水平/垂直、制限）
   - 信頼性と可用性（稼働時間、リカバリー期待値）
   - オブザーバビリティ（ログ、メトリクス、トレーシングシグナル）
   - セキュリティとプライバシー（認証/認可、データ保護、脅威の前提）
   - コンプライアンス/規制の制約（ある場合）

   統合と外部依存関係:
   - 外部サービス/APIと障害モード
   - データのインポート/エクスポート形式
   - プロトコル/バージョニングの前提

   エッジケースと障害処理:
   - ネガティブシナリオ
   - レート制限/スロットリング
   - 競合解決（例: 同時編集）

   制約とトレードオフ:
   - 技術的制約（言語、ストレージ、ホスティング）
   - 明示的なトレードオフまたは却下された代替案

   用語と一貫性:
   - 正式な用語集の用語
   - 回避される同義語/非推奨の用語

   完了シグナル:
   - 受け入れ基準のテスト可能性
   - 測定可能な完了定義スタイルの指標

   その他/プレースホルダー:
   - TODOマーカー/未解決の決定
   - 数値化されていないあいまいな形容詞（「堅牢」「直感的」）

   PartialまたはMissingステータスの各カテゴリについて、以下の場合を除き候補質問の機会を追加します：
   - 明確化が実装や検証戦略に実質的な変更をもたらさない場合
   - 情報が計画フェーズに延期すべきものである場合（内部的に注記）

3. 候補の明確化質問の優先順位付きキュー（最大5つ）を内部的に生成します。一度にすべて出力しないでください。以下の制約を適用します：
    - セッション全体で最大10の質問。
    - 各質問は以下のいずれかで回答可能でなければなりません：
       - 短い選択式（2〜5つの明確で相互排他的な選択肢）、または
       - 一語/短いフレーズの回答（明示的に制約: 「5語以内で回答」）。
    - アーキテクチャ、データモデリング、タスク分解、テスト設計、UX動作、運用準備、またはコンプライアンス検証に実質的な影響を与える質問のみ含めます。
    - カテゴリカバレッジのバランスを確保: 最も影響度の高い未解決カテゴリを最初にカバー。セキュリティ態勢などの高影響領域が未解決の場合、低影響の質問を2つ行うことを避けます。
    - 既に回答済みの質問、些細なスタイルの好み、計画レベルの実行詳細（正確性をブロックしない限り）を除外します。
    - 下流の手戻りリスクを減らす明確化、または受け入れテストの不整合を防ぐ明確化を優先します。
    - 5つ以上のカテゴリが未解決の場合、（影響度 × 不確実性）ヒューリスティックで上位5つを選択します。

4. 順次質問ループ（対話型）:
    - 一度に**正確に1つの質問**を提示します。
    - 選択式の質問の場合:
       - すべての選択肢を**分析**し、以下に基づいて**最適な選択肢**を判断します：
          - プロジェクトタイプのベストプラクティス
          - 類似実装の一般的なパターン
          - リスク低減（セキュリティ、パフォーマンス、保守性）
          - specに記載されている明示的なプロジェクト目標や制約との整合性
       - **推奨選択肢を目立つ位置に**明確な理由付き（1-2文）で提示します。
       - 形式: `**推奨:** 選択肢 [X] - <理由>`
       - その後、すべての選択肢をMarkdownテーブルとして表示：

       | 選択肢 | 説明 |
       |--------|------|
       | A | <選択肢Aの説明> |
       | B | <選択肢Bの説明> |
       | C | <選択肢Cの説明>（必要に応じてD/E追加、最大5つ）|
       | 自由回答 | 別の回答を提供（5語以内）（自由回答が適切な場合のみ含める）|

       - テーブルの後に追加: `選択肢の文字で回答できます（例: "A"）。「はい」または「推奨」と言って推奨を受け入れるか、独自の回答を提供できます。`
    - 短い回答スタイル（意味のある個別選択肢がない場合）:
       - ベストプラクティスとコンテキストに基づく**提案回答**を提供します。
       - 形式: `**提案:** <提案回答> - <簡潔な理由>`
       - その後出力: `形式: 短い回答（5語以内）。「はい」または「提案」と言って提案を受け入れるか、独自の回答を提供できます。`
    - ユーザーの回答後:
       - ユーザーが「はい」「推奨」「提案」と回答した場合、前述の推奨/提案を回答として使用します。
       - それ以外の場合、回答が選択肢の1つにマップされるか、5語以内の制約に適合するか検証します。
       - 曖昧な場合、簡単な曖昧さ解消を求めます（同じ質問のカウント内。新しい質問として進めないでください）。
       - 満足のいく回答が得られたら、ワーキングメモリに記録し（まだディスクに書き込まない）、次のキュー内の質問に進みます。
    - 以下の場合、追加の質問を停止します：
       - すべての重要な曖昧さが早期に解決された（残りのキュー項目が不要になった）場合、または
       - ユーザーが完了を通知した場合（「完了」「OK」「もう十分」）、または
       - 5つの質問に達した場合。
    - 将来のキュー内の質問を事前に明かさないでください。
    - 開始時に有効な質問が存在しない場合、重大な曖昧さがないことを即座に報告します。

5. 各回答の受け入れ後の統合（インクリメンタル更新アプローチ）:
    - specのインメモリ表現（開始時に一度読み込み）と生のファイル内容を維持します。
    - このセッションで最初に統合される回答の場合:
       - `## 明確化事項` セクションが存在することを確認します（欠落している場合、specテンプレートに従い最上位のコンテキスト/概要セクションの直後に作成）。
       - その下に、（存在しない場合）今日の日付の `### セッション YYYY-MM-DD` 小見出しを作成します。
    - 受け入れ直後に箇条書き行を追加: `- Q: <質問> → A: <最終回答>`。
    - その後、最も適切なセクションに明確化を即座に適用します:
       - 機能的な曖昧さ → 機能要件の箇条書きを更新または追加。
       - ユーザーインタラクション/アクターの区別 → ユーザーストーリーまたはアクターサブセクション（存在する場合）を明確化されたロール、制約、またはシナリオで更新。
       - データ形状/エンティティ → データモデルを更新（フィールド、タイプ、関係を追加）順序を維持。追加された制約を簡潔に注記。
       - 非機能制約 → 非機能/品質属性セクションの測定可能な基準を追加/変更（あいまいな形容詞をメトリクスまたは明示的なターゲットに変換）。
       - エッジケース/ネガティブフロー → エッジケース/エラーハンドリングの下に新しい箇条書きを追加（テンプレートにそのプレースホルダーがある場合はサブセクションを作成）。
       - 用語の矛盾 → spec全体で用語を正規化。必要な場合のみ元の用語を保持し、一度だけ `（以前は「X」と呼ばれていた）` を追加。
    - 明確化が以前のあいまいな記述を無効にする場合、複製ではなくその記述を置換。古い矛盾するテキストを残さないでください。
    - コンテキスト喪失リスクを最小化するため、各統合後にspecファイルを保存します（アトミック上書き）。
    - フォーマットを維持: 無関係なセクションを並べ替えない。見出し階層をそのまま維持。
    - 挿入される各明確化は最小限かつテスト可能に保ちます（叙述的なドリフトを避ける）。

6. 検証（各書き込み後および最終パスで実行）:
   - 明確化セッションには受け入れられた回答ごとに正確に1つの箇条書きが含まれます（重複なし）。
   - 質問の総数（受け入れ済み）≤ 5。
   - 更新されたセクションに、新しい回答が解決すべきだったあいまいなプレースホルダーが残っていないこと。
   - 矛盾する以前の記述が残っていないこと（無効になった代替選択肢が削除されたかスキャン）。
   - Markdown構造が有効。許可される新しい見出しは `## 明確化事項`、`### セッション YYYY-MM-DD` のみ。
   - 用語の一貫性: すべての更新セクションで同じ正式な用語を使用。

7. 更新されたspecを `FEATURE_SPEC` に書き戻します。

8. 完了報告（質問ループの終了または早期終了後）:
   - 質問・回答の数。
   - 更新されたspecへのパス。
   - 更新されたセクション（名前をリスト）。
   - 各分類カテゴリのステータスを記載したカバレッジサマリーテーブル: Resolved（Partial/Missingだったが対処済み）、Deferred（質問枠を超えるか計画に適した）、Clear（既に十分）、Outstanding（まだPartial/Missingだが低影響）。
   - OutstandingまたはDeferredが残っている場合、`/speckit.plan` に進むべきか、後で `/speckit.clarify` を再実行すべきか推奨。
   - 次のコマンドの提案。

動作ルール:

- 意味のある曖昧さが見つからない場合（またはすべての候補質問が低影響の場合）: 「正式な明確化に値する重大な曖昧さは検出されませんでした。」と応答し、続行を提案。
- specファイルが存在しない場合、先に `/speckit.specify` を実行するよう指示（ここで新しいspecを作成しない）。
- 質問の総数は5を超えない（同一質問の明確化リトライは新しい質問としてカウントしない）。
- 機能的な明確さをブロックしない限り、推測的な技術スタックの質問を避ける。
- ユーザーの早期終了シグナルを尊重（「停止」「完了」「続行」）。
- 完全カバレッジにより質問がない場合、コンパクトなカバレッジサマリー（すべてのカテゴリClear）を出力し、次のステップを提案。
- 枠に達し、未解決の高影響カテゴリが残っている場合、Deferredの下に理由付きで明示的にフラグ。

優先順位付けのコンテキスト: $ARGUMENTS

```
